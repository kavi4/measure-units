var measureUnits=function(e){"use strict";class t{abs(e){throw new Error("Method not implemented")}multiplication(e,t){throw new Error("Method not implemented")}division(e,t){throw new Error("Method not implemented")}greaterOrEqual(e,t){throw new Error("Method not implemented")}}class r extends t{abs(e){return Math.abs(e)}multiplication(e,t){return e*t}division(e,t){return e/t}greaterOrEqual(e,t){return e>=t}}class n extends Map{include(e){for(let t of this.keys())e.includes(t)||this.delete(t)}exclude(e){e.map((e=>{this.has(e)&&this.delete(e)}))}map(e){let t=new this.constructor;for(let r of this.keys())t.set(r,e(this.get(r),r,this));return t}}class i{canConvert(e){throw new Error("Method not implemented")}convert(e,t,r){throw new Error("Method not implemented")}convertToPreferUnit(e,t){throw new Error("Method not implemented")}}class s extends Error{}class o extends s{}return e.CoefficientMap=n,e.IMath=t,e.IMeasureUnitConverter=i,e.MeasureUnitConverter=class extends i{constructor(e){super();const{coefficientMap:i=new n,math:o=new r}=e;if(this.map=i,this.math=o,!(this.math instanceof t))throw new s("Math must be instance of IMath");if(!(this.map instanceof n))throw new s("CoefficientMap must be instance of CoefficientMap")}canConvert(e){return this.map.has(e)}convert(e,t,r){if(!this.map.has(t)||!this.map.has(r))throw new o("Measure unit undefined");const n=this.math.multiplication(e,this.map.get(t));return this.math.division(n,this.map.get(r))}convertToPreferUnit(e,t){if(!this.map.has(t))throw new o("Measure unit undefined");const r=this.math.abs(this.math.multiplication(e,this.map.get(t)));let n=null,i=e;for(let[e,t]of this.map){if(i=this.math.division(r,t),this.math.greaterOrEqual(i,1))return{unit:e,value:i};n=e}return{unit:n,value:i}}},e.MeasureUnitFacade=class extends i{constructor(e=[]){super(),this.converters=e}canConvert(e){return this.converters.some((t=>t.canConvert(e)))}convert(e,t,r){for(let n=0;n<this.converters.length;n++){let i=this.converters[n];if(i.canConvert(t)&&i.canConvert(r))return i.convert(e,t,r)}throw new o("Measure unit undefined")}convertToPreferUnit(e,t){for(let r=0;r<this.converters.length;r++){let n=this.converters[r];if(n.canConvert(t))return n.convertToPreferUnit(e,t)}throw new o("Measure unit undefined")}},e.NativeMath=r,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
