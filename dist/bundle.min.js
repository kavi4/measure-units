var measureUnits=function(e){"use strict";class t{abs(e){throw new Error("Method not implemented")}multiplication(e,t){throw new Error("Method not implemented")}division(e,t){throw new Error("Method not implemented")}greaterOrEqual(e,t){throw new Error("Method not implemented")}}class n extends t{abs(e){return Math.abs(e)}multiplication(e,t){return e*t}division(e,t){return e/t}greaterOrEqual(e,t){return e>=t}}class r extends Map{include(e){for(let t of this.keys())e.includes(t)||this.delete(t)}exclude(e){e.map((e=>{this.has(e)&&this.delete(e)}))}}class i{canConvert(e){throw new Error("Method not implemented")}convert(e,t,n){throw new Error("Method not implemented")}convertToPreferUnit(e,t){throw new Error("Method not implemented")}}class s extends Error{}class o extends s{}return e.CoefficientMap=r,e.IMath=t,e.IMeasureUnitConverter=i,e.MeasureUnitConverter=class extends i{constructor(e){super();const{coefficientMap:i=new r,math:o=new n}=e;if(this.map=i,this.math=o,!(this.math instanceof t))throw new s("Math must be instance of IMath");if(!(this.map instanceof r))throw new s("CoefficientMap must be instance of CoefficientMap")}canConvert(e){return this.map.has(e)}convert(e,t,n){if(!this.map.has(t)||!this.map.has(n))throw new o("Measure unit undefined");const r=this.math.multiplication(e,this.map.get(t));return this.math.division(r,this.map.get(n))}convertToPreferUnit(e,t){if(!this.map.has(t))throw new o("Measure unit undefined");const n=this.math.abs(this.math.multiplication(e,this.map.get(t)));let r=null,i=e;for(let[e,t]of this.map){if(i=this.math.division(n,t),this.math.greaterOrEqual(i,1))return{unit:e,value:i};r=e}return{unit:r,value:i}}},e.MeasureUnitFacade=class extends i{constructor(e=[]){super(),this.converters=e}canConvert(e){return this.converters.some((t=>t.canConvert(e)))}convert(e,t,n){for(let r=0;r<this.converters.length;r++){let i=this.converters[r];if(i.canConvert(t)&&i.canConvert(n))return i.convert(e,t,n)}throw new o("Measure unit undefined")}convertToPreferUnit(e,t){for(let n=0;n<this.converters.length;n++){let r=this.converters[n];if(r.canConvert(t))return r.convertToPreferUnit(e,t)}throw new o("Measure unit undefined")}},e.NativeMath=n,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
